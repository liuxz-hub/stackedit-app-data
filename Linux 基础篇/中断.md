# 一、Linux 内核中断处理简介←

## 1、裸机中断


## 2、 Linux 中断

### 1、先知道你要使用的中断对应的中断号

### 2、先申请 request_irg，此函数会激活中断

### 3、如果不用中断了，那就释放掉，使用 free_irg

### 4、中断处理函数 irqretumm_t(*irg_handler_t) (int, void *)

5、使能和禁止中断，*

## 3、上半部和下半部

&emsp;&emsp;中断一定要处理的越快越好，中断处理过程分为了两部分： 
 
1、上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。  

2、下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。  

因此， Linux 内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，至于哪些代码属于上半部，哪些代码属于下半部并没有明确的规定。这里有一些可以借鉴的参考点：

①、如果要处理的内容`不希望被其他中断打断`，那么可以放到上半部。

②、如果要处理的任务`对时间敏感`，可以放到上半部。 

③、如果要处理的任务`与硬件有关`，可以放到上半部  。 

④、除了上述三点以外的其他任务，优先考虑放到下半部。 

上半部处理很简单，直接编写中断处理函数就行了，关键是下半部该怎么做呢？ Linux 内  
核提供了多种下半部机制，接下来我们来学习一下这些下半部机制。

### 1、软中断

软中断请求 (softirq) 机制:

Linux 的 sofirq 机制是与 SMP 紧密不可分的。为此，整个 sofirg 机制的设计与实现中自始自终都贯彻了一个思想：“谁触发，谁执行”，即触发软中断的那个 CPU 负责执行它所触发的软中断，而且每个 CPU 都有它自己的软中断触发与控制机制。这个设计思想也使得 softirq 机制充分利用了 SMP 系统的性能和特点。

### 2. taskdlete

### 3、工作队列

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwMTc2NDgwMzVdfQ==
-->