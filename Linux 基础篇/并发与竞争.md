# 一、并发
## 1、并发原因

&emsp;&emsp;Linux 系统是个多任务操作系统，会存在多个任务同时访问同一片内存区域，这些任务可能会相互覆盖这段内存中的数据，造成内存数据混乱。针对这个问题必须要做处理，严重的话可能会导致系统崩溃。现在的 Linux 系统并发产生的原因很复杂，总结一下有下面几个主要原因：  
&emsp;&emsp;①、多线程并发访问， Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。  
&emsp;&emsp;②、抢占式并发访问，从 2.6 版本内核开始， Linux 内核支持抢占，也就是说调度程序可以在任意时刻抢占正在运行的线程，从而运行其他的线程。  
&emsp;&emsp;③、中断程序并发访问，这个无需多说，学过 STM32 的同学应该知道，硬件中断的权利可是很大的。  
&emsp;&emsp;④、 SMP(多核)核间并发访问，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并发访问。

&emsp;&emsp;要保护哪些数据？因为驱动程序各不相同，那么数据也千变万化，一般像全局变量，设备结构体这些肯定是要保护的，至于其他的数据就要根据实际的驱动程序而定了。

## 2、原子操作
原子操作就是指不能再进一步分割的操作，一般原子操作用于变量或者位操作。要解决并发与竞争问题就要保证  
将会产生该问题法人指令作为一个整体运行，也就是作为一个原子存在。 Linux 内核提供了一组原子操作 API 函数来完成&emsp;&emsp;此功能， Linux 内核提供了两组原子操作 API 函数，一组是对整形变量进行操作的，一组是对位进行操作的。

## 3、原子整形操作 API 函数

| 函数  | 描述  |
|------|------|
| `ATOMIC_INIT`&emsp;(int i) | 定义原子变量的时候对其初始化。 |
| `int atomic_read`&emsp;(atomic_t *v) | 读取 v 的值，并且返回。 |
| `void atomic_set`&emsp;(atomic_t *v, int i) | 向 v 写入 i 值。 |
| `void atomic_add`&emsp;(int i, atomic_t *v) | 给 v 加上 i 值。 |
| `void atomic_sub`&emsp;(int i, atomic_t *v) | 给 v 减去 i 值。 |
| `void atomic_inc`&emsp;(atomic_t *v) | 给 v 加 1，也就是自增。 |
| `void atomic_dec`&emsp;(atomic_t *v) | 从 v 减 1，也就是自减。 |
| `int atomic_dec_return`&emsp;(atomic_t *v) | 从 v 减 1，并且返回 v 的值。 |
| `int atomic_inc_return`&emsp;(atomic_t *v) | 给 v 加 1，并且返回 v 的值。 |
| `int atomic_sub_and_test`&emsp;(int i, atomic_t *v) | 从 v 减 i，如果结果为 0 就返回真，否则返回假。 |
| `int atomic_dec_and_test`&emsp;(atomic_t *v) | 从 v 减 1，如果结果为 0 就返回真，否则返回假。 |
| `int atomic_inc_and_test`&emsp;(atomic_t *v) | 给 v 加 1，如果结果为 0 就返回真，否则返回假。 |
| `int atomic_add_negative`&emsp;(int i, atomic_t *v) | 给 v 加 i，如果结果为负就返回真，否则返回假。 |

&emsp;&emsp;相应的也提供了 64 位原子变量的操作 API 函数，和上表中的 API 函数有用法一样，只是将 `atomic_`前缀换为`atomic64_`，将 `int` 换为 `long long`。

## 4、原子位操作 API 函数
&emsp;&emsp;Linux 内核也提供了一系列的原子位操作 API 函数，只不过原子位操作不像原子整形变量那样有个 atomic_t 的数据结构，原子位操作是直接对内存进行操作。
| 函数 | 描述 |
|------|------|
| `void set_bit`&emsp;(int nr, void *p)   | 将 p 地址的第 nr 位置 1。 |
| `void clear_bit`&emsp;(int nr, void *p) | 将 p 地址的第 nr 位清零。 |
| `void change_bit`&emsp;(int nr, void *p) | 将 p 地址的第 nr 位进行翻转。 |
| `int test_bit`&emsp;(int nr, void *p) | 获取 p 地址的第 nr 位的值。 |
| `int test_and_set_bit`&emsp;(int nr, void *p) | 将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值。 |
| `int test_and_clear_bit`&emsp;(int nr, void *p) | 将 p 地址的第 nr 位清零，并且返回 nr 位原来的值。 |
| `int test_and_change_bit`&emsp;(int nr, void *p) | 将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值。 |

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2NzAyNTMyNTgsLTY5NTU1Mzg4NywtNj
kwNDc5NDAsMTE0NDI0MDc0OF19
-->