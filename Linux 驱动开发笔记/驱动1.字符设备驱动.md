# 一、字符设备驱动框架
字符设备驱动的编写主要就是驱动对应的open、cose、read · · · ，其实就是file_operations 结构体的成员变量的实现。

# 二、驱动模块的加载与卸载
Linux 驱动程序可以编译到 kernel 里面，也就是 zlmage，也可以编译为模块即 .ko 文件。测试的时候只需要加载 .ko 模块就可以，避免了重复烧录。

1、编译驱动的时候需要用到 linux 内核源码！因此要解压缩 linux,内核源码。编译 linux 内核源码。得到 zlmage 和 dtb 文件。需要使用编译后的到的 zlmage 和 dtb 启动系统；

2、从 SD 卡启动，SD 卡烧写了uboot，uboot 通过 tftp 从 ubuntu 里面获取 zlmage 和 dtb 文件。rootfs 根文件系统也是通过 nís 挂载；

3、设置 bootcmd 和 bootargs 
bootcmd=tftp 80800000 zlmage:tftp 83000000 imx6ull-alientek-emmc.dtb;bootz 8080000083000000

bootargs=console=ttymxc0, 115200 nfsroot=192.168.61.100:home/lxz/linux/nfs/rootfs ip=192.168.61.50:192.168,61.100:192168.61.1:255.255.255.0:eth0:off
 
 4、将编译出来的.ko 文件放在根文件系统里，加载驱动推荐使用指令 modprobe（可加载依赖关系），移除驱动推荐使用指令 rmmod。驱动模块加载成功以后可以使用lsmod 查看，卸载模块使用 rmmod 命令
 
# 三、字符设备的注册与注销



# 四、file_operations 的具体实现


# 五、测试
1、加载驱动：modprobe chrdevbase.ko；

2、进入 /dev 查看设备文件 chrdevbase。/dev/chrdevbase
但是实际没有，因为还没有创建设备节点；

mknod /dev/chrdeybase c 200 0

3、测试：
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTEwNDIwNTAyMSwtMTQzNTY1MjU0NywtMT
I0NjExODg1MCwtNjUxOTAzODg4LDQ3NzU3NDQwOCwtMTM0NzQ2
MTUyMCwtMjA4ODc0NjYxMl19
-->