# 一、阻塞和非阻塞 IO
&emsp;&emsp;当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么阻塞式 IO 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。对于非阻塞 IO，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。

![输入图片说明](/imgs/2025-07-05/CxieBnN6gO5gpgzn.png)

&emsp;&emsp;上图中应用程序调用 read 函数从设备中读取数据，当设备不可用或数据未准备好的时候就会进入到休眠态。等设备可用的时候就会从休眠态唤醒，然后从设备中读取数据返回给应用程序。非阻塞 IO 如下图所示：

![输入图片说明](/imgs/2025-07-05/nmbUm4UezS7ptEbx.png)

&emsp;&emsp;可以看出，应用程序使用非阻塞访问方式从设备读取数据，当设备不可用或数据未准备好的时候会立即向内核返回一个错误码，表示数据读取失败。应用程序会再次重新读取数据，这样一直往复循环，直到数据读取成功。

&emsp;&emsp;对于设备驱动文件的默认读取方式就是阻塞式的，所以我们前面所有的例程测试 APP 都是采用阻塞 IO。

# 二、等待队列
## 1、修改设备数
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTkyNjQ4Mzg2OCwtMTAxNjg3NzY4MCwxNj
kzMjMzMTMwXX0=
-->