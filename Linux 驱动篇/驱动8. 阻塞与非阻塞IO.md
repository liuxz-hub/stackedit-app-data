# 一、阻塞和非阻塞 IO
&emsp;&emsp;当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么`阻塞式 IO` 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU 资源让出来对于`非阻塞 IO`，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。

![输入图片说明](/imgs/2025-07-05/CxieBnN6gO5gpgzn.png)

&emsp;&emsp;上图中应用程序调用 read 函数从设备中读取数据，当设备不可用或数据未准备好的时候就会进入到休眠态。等设备可用的时候就会从休眠态唤醒，然后从设备中读取数据返回给应用程序。
```cpp
/*示例代码:应用程序阻塞读取数据*/
int fd;  
int data = 0;  
fd = open("/dev/xxx_dev", O_RDWR); /* 阻塞方式打开 */  
ret = read(fd, &data, sizeof(data)); /* 读取数据 */
```

![输入图片说明](/imgs/2025-07-05/nmbUm4UezS7ptEbx.png)

&emsp;&emsp;非阻塞 IO 如上图所示：应用程序使用非阻塞访问方式从设备读取数据，当设备不可用或数据未准备好的时候会立即向内核返回一个错误码，表示数据读取失败。应用程序会再次重新读取数据，这样一直往复循环，直到数据读取成功。

&emsp;&emsp;对于设备驱动文件的`默认读取方式`就是`阻塞式`的，所以我们前面所有的例程测试 APP 都是采用阻塞 IO。

```cpp
/*示例代码:应用程序非阻塞读取数据*/
int fd;  
int data = 0;  
fd = open("/dev/xxx_dev", O_RDWR | O_NONBLOCK); /* 非阻塞方式打开 */  
ret = read(fd, &data, sizeof(data)); /* 读取数据 */
```

# 二、等待队列
## 1、等待队列头
&emsp;&emsp;阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU 资源让出来。但是，当设备文件可以操作的时候就必须唤醒进程，一般在中断函数里面完成唤醒工作。 Linux 内核提供了等待队列`(wait queue)`来实现阻塞进程的唤醒工作，如果我们要在驱动中使用等待队列，必须创建并初始化一个等待队列头，等待队列头使用结构体`wait_queue_head_t`表示。

首先使用`typedef struct __wait_queue_head wait_queue_head_t;`来定义等待队列头，之后使用`void init_waitqueue_head(wait_queue_head_t *q)`进行初始化。

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExNzAyMjY4ODQsLTE4NDQ5NDA4MTUsLT
E4NzMxNDkyMTMsNjMyMTg0MTM5LC0xMDE2ODc3NjgwLDE2OTMy
MzMxMzBdfQ==
-->