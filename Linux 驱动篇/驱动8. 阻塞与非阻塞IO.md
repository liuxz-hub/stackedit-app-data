# 一、阻塞和非阻塞 IO
&emsp;&emsp;当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么`阻塞式 IO` 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU 资源让出来对于`非阻塞 IO`，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。

![输入图片说明](/imgs/2025-07-05/CxieBnN6gO5gpgzn.png)

&emsp;&emsp;上图中应用程序调用 read 函数从设备中读取数据，当设备不可用或数据未准备好的时候就会进入到休眠态。等设备可用的时候就会从休眠态唤醒，然后从设备中读取数据返回给应用程序。非阻塞 IO 如下图所示：

![输入图片说明](/imgs/2025-07-05/nmbUm4UezS7ptEbx.png)

&emsp;&emsp;可以看出，应用程序使用非阻塞访问方式从设备读取数据，当设备不可用或数据未准备好的时候会立即向内核返回一个错误码，表示数据读取失败。应用程序会再次重新读取数据，这样一直往复循环，直到数据读取成功。

&emsp;&emsp;对于设备驱动文件的`默认读取方式`就是`阻塞式`的，所以我们前面所有的例程测试 APP 都是采用阻塞 IO。

# 二、等待队列
## 1、修改设备数
<!--stackedit_data:
eyJoaXN0b3J5IjpbNjMyMTg0MTM5LC0xMDE2ODc3NjgwLDE2OT
MyMzMxMzBdfQ==
-->