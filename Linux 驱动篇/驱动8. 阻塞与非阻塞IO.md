# 一、阻塞和非阻塞 IO
&emsp;&emsp;当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么`阻塞式 IO` 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU 资源让出来对于`非阻塞 IO`，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。

![输入图片说明](/imgs/2025-07-05/CxieBnN6gO5gpgzn.png)

&emsp;&emsp;上图中应用程序调用 read 函数从设备中读取数据，当设备不可用或数据未准备好的时候就会进入到休眠态。等设备可用的时候就会从休眠态唤醒，然后从设备中读取数据返回给应用程序。
```cpp
/*示例代码:应用程序阻塞读取数据*/
int fd;  
int data = 0;  
fd = open("/dev/xxx_dev", O_RDWR); /* 阻塞方式打开 */  
ret = read(fd, &data, sizeof(data)); /* 读取数据 */
```

![输入图片说明](/imgs/2025-07-05/nmbUm4UezS7ptEbx.png)

&emsp;&emsp;非阻塞 IO 如上图所示：应用程序使用非阻塞访问方式从设备读取数据，当设备不可用或数据未准备好的时候会立即向内核返回一个错误码，表示数据读取失败。应用程序会再次重新读取数据，这样一直往复循环，直到数据读取成功。

&emsp;&emsp;对于设备驱动文件的`默认读取方式`就是`阻塞式`的，所以我们前面所有的例程测试 APP 都是采用阻塞 IO。

```cpp
/*示例代码:应用程序非阻塞读取数据*/
int fd;  
int data = 0;  
fd = open("/dev/xxx_dev", O_RDWR | O_NONBLOCK); /* 非阻塞方式打开 */  
ret = read(fd, &data, sizeof(data)); /* 读取数据 */
```

# 二、等待队列
## 1、等待队列头
&emsp;&emsp;阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU 资源让出来。但是，当设备文件可以操作的时候就必须唤醒进程，一般在中断函数里面完成唤醒工作。 Linux 内核提供了等待队列`(wait queue)`来实现阻塞进程的唤醒工作，如果我们要在驱动中使用等待队列，必须创建并初始化一个等待队列头，等待队列头使用结构体`wait_queue_head_t`表示。

首先使用`typedef struct __wait_queue_head wait_queue_head_t;`来定义等待队列头，之后使用`void init_waitqueue_head(wait_queue_head_t *q)`进行初始化，也可以使用宏`DECLARE_WAIT_QUEUE_HEAD`来一次性完成等待队列头的定义和初始化。

## 2、等待队列项
`typedef struct __wait_queue wait_queue_t;`

&emsp;&emsp;使用宏 `DECLARE_WAITQUEUE` 定义并初始化一个等待队列项，宏的内容如下：  
```cpp
DECLARE_WAITQUEUE(name, tsk)
```
&emsp;&emsp;name 就是等待队列项的名字， tsk 表示这个等待队列项属于哪个任务(进程)，一般设置为 current ， 在 Linux 内核中 current 相当于一个全局变量 ，表示当前进程 。 因此宏 `DECLARE_WAITQUEUE` 就是给当前正在运行的进程创建并初始化了一个等待队

## 3、添加等待队列项到等待队列头
&emsp;&emsp;当设备不可访问的时候就需要将进程对应的等待队列项添加到前面创建的等待队列头中，  
以后进程才能进入休眠态。当设备可以访问以后再将进程对应的等待队列项从等待队列头中移除即可，等待队列项添加 API 函数如下：

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI2Nzk1NDUxOCwtMTg0NDk0MDgxNSwtMT
g3MzE0OTIxMyw2MzIxODQxMzksLTEwMTY4Nzc2ODAsMTY5MzIz
MzEzMF19
-->