# 一、input 子系统
## 1.1 input 子系统简介
    input 子系统就是管理输入的子系统，和 pinctrl、gpio 子系统一样，都是 Linux 内核针对某一类设备而创建的框架。比如按键输入、键盘、鼠标、触摸屏等等这些都属于输入设备，不同的输入设备所代表的含义不同，按键和键盘就是代表按键信息，鼠标和触摸屏代表坐标信息，因此在应用层的处理就不同，对于驱动编写者而言不需要去关心应用层的事情，我们只需要按照要求上报这些输入事件即可。为此 input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点，input 子系统框架如下图所示：
    （图 58.1.1.1 input 子系统结构图）
    可以看出 input 子系统用到了我们前面讲解的驱动分层模型，我们编写驱动程序的时候只需要关注中间的驱动层、核心层和事件层，这三个层的分工如下：
    1、驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容；
    2、核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理；
    3、事件层：主要和用户空间进行交互。
    
# 二、input 驱动编写流程
## 2.1 注册 input_dev
input_dev 注册过程如下：
①、使用 input_allocate_device 函数申请一个 input_dev；
②、初始化 input_dev 的事件类型以及事件值；
③、使用 input_register_device 函数向 Linux 系统注册前面初始化好的 input_dev。
④、卸载 input 驱动的时候需要先使用 input_unregister_device 函数注销掉注册的 input_dev，然后使用 input_free_device 函数释放掉前面申请的 input_dev。

|  函数  |  描述  |  参数/返回值  |
|--------|--------|--------------|
|struct input_dev *input_allocate_device(void)|申请 input_dev 结构体变量|返回值：申请到的 input_dev|
|void input_free_device(struct input_dev *dev)|释放 input_dev 结构体变量|dev：需要释放的 input_dev。|
|int input_register_device(struct input_dev *dev)|向 Linux 内核注册 input_dev|dev：要注册的 input_dev|
|void input_unregister_device(struct input_dev *dev)|向 Linux 内核注销 input_dev|dev：要注销的 input_dev|


```cpp
/* input 结构体变量 */
struct input_dev *inputdev;

/* 驱动入口函数 */
static int __init xxx_init(void)
{
	...... 
	inputdev = input_allocate_device(); /* 申请 input_dev
	inputdev->name = "test_inputdev";   /* 设置 input_dev 名字 */
	/*********第一种设置事件和事件值的方法***********/
 	__set_bit(EV_KEY, inputdev->evbit); /* 设置产生按键事件 */
 	__set_bit(EV_REP, inputdev->evbit); /* 重复事件 */
 	__set_bit(KEY_0, inputdev->keybit);/*设置产生哪些按键值*/
	/************************************************/

	/*********第二种设置事件和事件值的方法***********/
	keyinputdev.inputdev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
	keyinputdev.inputdev->keybit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);
	/************************************************/

	/*********第三种设置事件和事件值的方法***********/
	keyinputdev.inputdev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
	input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);
	/************************************************/

	/* 注册 input_dev */
	input_register_device(inputdev);
	......
	return 0;
}

/* 驱动出口函数 */
static void __exit xxx_exit(void)
{
	input_unregister_device(inputdev); /* 注销 input_dev */
	input_free_device(inputdev);	    /* 删除 input_dev */
}
```

## 2.1 上报输入事件
    input 设备都是具有输入功能的，但是具体是什么样的输入值 Linux 内核是不知道的，我们需要获取到具体的输入值，或者说是输入事件，然后将输入事件上报给 Linux 内核。不同的事件，其上报事件的 API 函数不同。
    
    一般性上报 API 函数：
```cpp
	void input_event(
		struct input_dev	*dev,    /*需要上报的 input_dev*/
		unsigned int 		type,    /*上报的事件类型，比如 EV_KEY*/
		unsigned int		code,    /*事件码，也就是我们注册的按键值，比如 KEY_0、KEY_1 等等*/
		int			value    /*事件值，比如 1 表示按键按下，0 表示按键松开*/
	)
```








































<!--stackedit_data:
eyJoaXN0b3J5IjpbMjAxNTU5OTMyNl19
-->