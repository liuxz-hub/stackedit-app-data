
# 一、rtc_device 结构体
&emsp;&emsp;RTC 也是一个标准的字符设备驱动，`rtc_device` 是 RTC 设备在内核中的具体实现，`rtc_device` 结构体定义在`rtc.h`中，重点是包括`rtc_class_ops`操作集合：
```cpp
struct rtc_class_ops {
	int (*open)(struct device *);
	void (*release)(struct device *);
	int (*ioctl)(struct device *, unsigned int, unsigned long);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*set_mmss64)(struct device *, time64_t secs);
	int (*set_mmss)(struct device *, unsigned long secs);
	int (*read_callback)(struct device *, int data);
	int (*alarm_irq_enable)(struct device *, unsigned int enabled);
};
```
&emsp;&emsp;RTC 是个字符设备，那么肯定有字符设备的 `file_operations` 函数操作集， Linux 内核提供了一个 RTC 通用字符设备驱动文件，文件名为 `drivers/rtc/rtc-dev.c`， `rtcdev.c` 文件提供了所有 RTC 设备共用的 `file_operations` 函数操作集，如下所示：
```cpp
static const struct file_operations rtc_dev_fops = {  
	.owner = THIS_MODULE,  
	.llseek = no_llseek,  
	.read = rtc_dev_read,  
	.poll = rtc_dev_poll,  
	.unlocked_ioctl = rtc_dev_ioctl,  
	.open = rtc_dev_open,  
	.release = rtc_dev_release,  
	.fasync = rtc_dev_fasync,  
};
```
应用程序可以通过 `ioctl` 函数来设置/读取时间、设置/读取闹钟的操作，那么对应的 `rtc_dev_ioctl `函数就会执行，`rtc_dev_ioctl` 最终会通过操作 `rtc_class_ops` 中的 `read_time`、 `set_time` 等函数来对具体 RTC 设备的读写操作。

如果是读取时间命令的话就调用 `rtc_read_time` 函数获取当前 RTC 时钟，  
`rtc_read_time` 函数， `rtc_read_time 会调用__rtc_read_time 函数

# 二、 IMX6ULL RTC 驱动简析
# 2.1 RTC 相关节点
在`imx6ull.dtsi` 中可以找到RTC 相关节点如下：
```cpp
snvs: snvs@020cc000 {
	compatible = "fsl,sec-v4.0-mon", "syscon", "simple-mfd";
	reg = <0x020cc000 0x4000>;

	snvs_rtc: snvs-rtc-lp {
		compatible = "fsl,sec-v4.0-mon-rtc-lp";
		regmap = <&snvs>;
		offset = <0x34>;
		interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>;
	};
};
```
根据 `compatible = "fsl,sec-v4.0-mon-rtc-lp";`可以找到 NXP 提供的驱动文件`rtc-snvs.c`。

# 2.2 
在驱动与设备匹配之后，`snvs_rtc_probe` 函数就会执行，进行RTC 的初始化、申请和中断闹钟，中断处理函数是 `snvs_rtc_irq_handler`
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTU1ODkwOTQ4LDIwNTg1NzgyMjgsLTE1MD
Y2MDkzMzNdfQ==
-->