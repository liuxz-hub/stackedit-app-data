
# 一、rtc_device 结构体
&emsp;&emsp;RTC 也是一个标准的字符设备驱动，`rtc_device` 是 RTC 设备在内核中的具体实现，`rtc_device` 结构体定义在`rtc.h`中，重点是包括`rtc_class_ops`操作集合：
```cpp
struct rtc_class_ops {
	int (*open)(struct device *);
	void (*release)(struct device *);
	int (*ioctl)(struct device *, unsigned int, unsigned long);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*set_mmss64)(struct device *, time64_t secs);
	int (*set_mmss)(struct device *, unsigned long secs);
	int (*read_callback)(struct device *, int data);
	int (*alarm_irq_enable)(struct device *, unsigned int enabled);
};
```

# 二、 IMX6ULL RTC 驱动简析
# 2.1 RTC 相关节点
在`imx6ull.dtsi` 中可以找到RTC 相关节点如下：
```cpp
snvs: snvs@020cc000 {
	compatible = "fsl,sec-v4.0-mon", "syscon", "simple-mfd";
	reg = <0x020cc000 0x4000>;

	snvs_rtc: snvs-rtc-lp {
		compatible = "fsl,sec-v4.0-mon-rtc-lp";
		regmap = <&snvs>;
		offset = <0x34>;
		interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>;
	};
};
```
根据 `compatible = "fsl,sec-v4.0-mon-rtc-lp";`可以找到 NXP 提供的驱动文件`rtc-snvs.c`。

# 2.2 
在驱动与设备匹配之后，`snvs_rtc_probe` 函数就会执行
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1MDY2MDkzMzNdfQ==
-->