# 一、CONCTRL 子系统

# 二、GPIO 子系统

# 三、编写驱动

## 3.1  修改设备树
打开设备树文件 `imx6ull-alientek-emmc.dts` 添加项目的根节点 `gpioled`（也是系统的一级子节点），设置根节点 gpioled 属性：
``` cpp
	gpioled{
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_gpioled>; /* 子节点 */
		compatible = "alientek,gpioled";
		led-gpios = <&gpio1 3 GPIO_ACTIVE_LOW>;
		status = "okay";
	};
```
其中，子节点`pinctrl_gpioled` 定义在节点`iomuxc`中：
 ``` cpp
	pinctrl_gpioled: ledrp {
			fsl,pins = <
				MX6UL_PAD_GPIO1_IO03__GPIO1_IO03    0X10B0
			>;
		};
```
`MX6UL_PAD_GPIO1_IO03__GPIO1_IO03` 表示将 `GPIO1_IO03`复用为本身（LED 接的 IO 口就是 IO03），`0X10B0` 是电气属性。

添加之后可以在开发版上进去 Linux 系统，通过命令`cd /proc/device-tree`进去，`ls`查看节点`gpioled`是否存在。

## 3.2  驱动编写
### 3.2.1 搭建驱动框架
>1、注册和卸载设备驱动；
2、定义入口和出口函数；

### 3.2.2 字符设备驱动

1、创建 gpio 设备结构体 `gpioled_dev`，初步定义以下成员，后续再添加
 ``` cpp
	struct gpioled_dev{
	    dev_t   devid;
	    int     major;
	    int     minor;
	};
	struct gpioled_dev gpioled;
 ```
 2、注册字符设备驱动
 ```
	 1) 申请设备号
	 2} 向设备号添加字符设备 cdev
		 2.1) 初始化cdev
		 2.2) 添加cdev
		 2.3) 自动创建设备节点
			 2.3.1) 创建类
			 2.3.2) 创建设备
```
	1). 申请设备号
111
 
<!--stackedit_data:
eyJoaXN0b3J5IjpbMzk1NTE3MTY0LDY1NTYzMjM0MCwzODE2Nz
k3NDQsLTY5NjQ3NDYwMCwxNjk5MzUwNDYzLC03MzA4MzA4ODIs
MTY5NjE4MDQ4OF19
-->