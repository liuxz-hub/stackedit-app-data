# 一、应用端
&emsp;&emsp;应用使用 `signal` 函数，设置信号处理函数，原型为
```cpp
sighandler_t signal(int signum, sighandler_t handler);
```
信号处理函数为:
```cpp
typedef void (*sighandler_t)(int);
```

`CTRL+C` 关闭应用，发送的`SIGINT`信号，做出修改：添加打印
```cpp
#include "stdlib.h"
#include "stdio.h"
#include "signal.h"

void sigint_handler(int num)
{
    printf("\r\nSIGINT signal!\r\n");
    exit(0);
}

int main(void)
{
    signal(SIGINT, sigint_handler);
    while(1);
    return 0;
}
```

那么，驱动端谁向应用发送信号?

# 二、驱动端
&emsp;&emsp;需要实现 `file_eperations` 中的`fasync` 函数，函数原型如下：
```cpp
int (*fsync) (struct file *, loff_t, lolf_t, int datasync);
```

1、要使用 `fasymc_struct` 定义一个指针结构体变量。
2、实现 `file_operations` 里面的 `fasyc`函数，函数原型:
```cpp
int (*fasync) (int struct file *, int);
```
3、驱动里面调用 `fasync`，向应用发送信号，函数原型：
```cpp
void kill_fasync(struct fasync_struct **fp, int sig, int band);
```
4、关闭驱动的时候要删除信号:


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwMzcxNDc2MV19
-->