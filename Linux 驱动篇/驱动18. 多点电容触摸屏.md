# 一、多点电容触摸屏驱动框架

1、电容触摸屏上报多点触摸信息，通过触摸芯片（比如FT5426）。多算电容触摸屏本质是IIC驱动。

2、触摸IC一般都是有INT的，当检测到触摸信息以后就会触发中断想赢，那么就要在中断处理函数里面读取触摸点信息。

3、得到触摸点信息以后，Linux如何使用？		Linux下有触摸屏上报的流程，涉及到inout子系统下的信息上报。

# 二、MT 协议
## 1、Type A
适用于触摸点不能被区分或者追踪，一股脑全部上报所有触摸点信息系统去甄别这些信息属于哪个触摸点（此类型在实际使用中非常少！ )。

触摸点的信息通过一系列的 `ABS_MT` 事件上报给 linux 内核的。
```cpp
   /* 两点触摸 */
   ABS_MT_POSITION_X x[0]   /*触摸点 0 的 x 轴坐标，使用input_report_ads*/
   ABS_MT_POSITION_Y y[0]	/*触摸点 0 的 y 轴坐标*/
   SYN_MT_REPORT			/*不同触摸点用该事件隔离*/
   ABS_MT_POSITION_X x[1]	/*触摸点 1 的 x 轴坐标*/
   ABS_MT_POSITION_Y y[1]	/*触摸点 1 的 y 轴坐标*/
   SYN_MT_REPORT
   SYN_REPORT				/*所有触摸点上报完成，使用input_sync*/
```

## 2、Type B
适用于有硬件追踪并能区分触摸点的触摸设备，通过 slot 机制区分且更新各触摸点的信息， `FT5426 `就属于此类型，一般的多点电容触摸屏 IC 都有此能力。
```cpp
   ABS_MT_SLOT 0			/*下面上报触摸点 0 信息,使用input_mt_slot*/
   ABS_MT_TRACKING_ID 45	/*通过调用input_mt_report_slot_state函数*/
   ABS_MT_POSITION_X x[0]	/*触摸点 0 的 x 轴坐标*/
   ABS_MT_POSITION_Y y[0]	/*触摸点 0 的 y 轴坐标*/
   ABS_MT_SLOT 1			/*下面上报触摸点 1 信息*/
   ABS_MT_TRACKING_ID 46
   ABS_MT_POSITION_X x[1]	/*触摸点 1 的 x 轴坐标*/
   ABS_MT_POSITION_Y y[1]	/*触摸点 1 的 y 轴坐标*/
   SYN_REPORT				/*所有触摸点上报完成，使用input_sync*/
```

# 三、API函数
|  函数  |  描述  |  参数/返回值  |
|--------|--------|--------------|
|int input_mt_init_slots( struct input_dev *dev,  unsigned int  num_slots,  unsigned int flags)|初始化 MT 的输入 slots|dev： MT 设备对应的 input_dev， num_slots：设备要使用的 SLOT 数量|
|void input_mt_slot(struct input_dev  *dev, int  slot)|用于产生 ABS_MT_SLOT 事件，告诉内核当前上报的是哪个触摸点的坐标数据|dev： MT 设备对应的 input_dev,slot：当前发送的是哪个触摸点|
|void input_mt_report_slot_state( struct input_dev  *dev, unsigned int tool_type,bool  active)|绑定触摸点|tool_type：触摸类型，active： true是连续触摸， false是触摸点抬起|
|void input_report_abs( struct input_dev  *dev,  unsigned int  code,  int value)|上报触摸点坐标信息|code：要上报的是 X 轴或者 Y 轴，value： 具体的 坐标数据值。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTY5MzI2NDQ0MywtMTczNDg3ODU1NywtMT
MxODkwNjcwNCwxMDIzMzY4MjE1LDM3MzEwMTIwMSwxMDI0ODcx
ODgyLDE2NDQ0MzI0NTksLTIwODg3NDY2MTJdfQ==
-->