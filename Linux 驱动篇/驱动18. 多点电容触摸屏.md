# 一、多点电容触摸屏驱动框架

1、电容触摸屏上报多点触摸信息，通过触摸芯片（比如FT5426）。多算电容触摸屏本质是IIC驱动。

2、触摸IC一般都是有INT的，当检测到触摸信息以后就会触发中断想赢，那么就要在中断处理函数里面读取触摸点信息。

3、得到触摸点信息以后，Linux如何使用？		Linux下有触摸屏上报的流程，涉及到inout子系统下的信息上报。

# 二、MT 协议
## 1、Type A
适用于触摸点不能被区分或者追踪，一股脑全部上报所有触摸点信息系统去甄别这些信息属于哪个触摸点（此类型在实际使用中非常少！ )。

触摸点的信息通过一系列的 `ABS_MT` 事件上报给 linux 内核的。
```cpp
   /* 两点触摸 */
   ABS_MT_POSITION_X x[0]   /*触摸点 0 的 x 轴坐标，使用input_report_ads*/
   ABS_MT_POSITION_Y y[0]	/*触摸点 0 的 y 轴坐标*/
   SYN_MT_REPORT			/*不同触摸点用该事件隔离*/
   ABS_MT_POSITION_X x[1]	/*触摸点 1 的 x 轴坐标*/
   ABS_MT_POSITION_Y y[1]	/*触摸点 1 的 y 轴坐标*/
   SYN_MT_REPORT
   SYN_REPORT				/*所有触摸点上报完成，使用input_sync*/
```

## 2、Type B
适用于有硬件追踪并能区分触摸点的触摸设备，通过 slot 机制区分且更新各触摸点的信息， `FT5426 `就属于此类型，一般的多点电容触摸屏 IC 都有此能力。
```cpp
   ABS_MT_SLOT 0			/*下面上报触摸点 0 信息,使用input_mt_slot*/
   ABS_MT_TRACKING_ID 45	/*通过调用input_mt_report_slot_state函数*/
   ABS_MT_POSITION_X x[0]	/*触摸点 0 的 x 轴坐标*/
   ABS_MT_POSITION_Y y[0]	/*触摸点 0 的 y 轴坐标*/
   ABS_MT_SLOT 1			/*下面上报触摸点 1 信息*/
   ABS_MT_TRACKING_ID 46
   ABS_MT_POSITION_X x[1]	/*触摸点 1 的 x 轴坐标*/
   ABS_MT_POSITION_Y y[1]	/*触摸点 1 的 y 轴坐标*/
   SYN_REPORT				/*所有触摸点上报完成，使用input_sync*/
```

# 三、API函数
|  函数  |  描述  |  参数/返回值  |
|--------|--------|--------------|
|int input_mt_init_slots( struct input_dev *dev,  unsigned int  num_slots,  unsigned int flags)|初始化 MT 的输入 slots|dev： MT 设备对应的 input_dev， num_slots：设备要使用的 SLOT 数量|
|void input_mt_slot(struct input_dev  *dev, int  slot)|用于产生 ABS_MT_SLOT 事件，告诉内核当前上报的是哪个触摸点的坐标数据|dev： MT 设备对应的 input_dev,slot：当前发送的是哪个触摸点|
|void input_mt_report_slot_state( struct input_dev  *dev, unsigned int tool_type,bool  active)|绑定触摸点|tool_type：触摸类型，active： true是连续触摸， false是触摸点抬起|
|void input_report_abs( struct input_dev  *dev,  unsigned int  code,  int value)|上报触摸点坐标信息|code：要上报的是 X 轴或者 Y 轴，value： 具体的 坐标数据值
|void input_mt_report_pointer_emulation(struct input_dev *dev, bool use_count)|获取到具体的触摸点数量|use_count： true，有效的触摸点数量； false，追踪到的触摸点数量多于当前上报的数量


# 四、多点电容触摸驱动框架
## 1、 I2C 驱动框架
```cpp
1 /* 设备树匹配表 */  
2 static const struct i2c_device_id xxx_ts_id[] = {  
3 		{ "xxx", 0, },  
4 		{ /* sentinel */ }  
5 };  
6 
7 /* 设备树匹配表 */  
8 static const struct of_device_id xxx_of_match[] = {  
9 		{ .compatible = "xxx", },  
10	    { /* sentinel */ }  
11 };  
12  
13 /* i2c 驱动结构体 */  
14 static struct i2c_driver ft5x06_ts_driver = {  
15      .driver = {  
16      .owner = THIS_MODULE,  
17      .name = "edt_ft5x06",  
18      .of_match_table = of_match_ptr(xxx_of_match),  
19 },  
20 .id_table = xxx_ts_id,  
21      .probe = xxx_ts_probe,
22      .remove = xxx_ts_remove,
23 };  
24  
25 /* 驱动入口函数   */  
30 static int __init xxx_init(void)  
31 {  
32		 int ret = 0;  
34		 ret = i2c_add_driver(&xxx_ts_driver);  
36	     return ret;  
37 }  
38  
39 /*驱动出口函数 */  
44 static void __exit xxx_exit(void)  
45 {  
46		  i2c_del_driver(&ft5x06_ts_driver);  
47 }  
48  
49 module_init(xxx_init);  
50 module_exit(xxx_exit);  
51
52 MODULE_LICENSE("GPL");  
53 MODULE_AUTHOR("xxx");

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTkyNjM0MzIzMCwtMTE5MzY5ODg5MSwtMT
czNDg3ODU1NywtMTMxODkwNjcwNCwxMDIzMzY4MjE1LDM3MzEw
MTIwMSwxMDI0ODcxODgyLDE2NDQ0MzI0NTksLTIwODg3NDY2MT
JdfQ==
-->